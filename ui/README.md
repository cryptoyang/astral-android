# Optional Open User Interface

Document describes the idea of flexible, transparent and replaceable UI.

Keep in mind that everything down below reflects only the developer needs, any fully omits the UX
context, but any UX problem should be possible to solve basing on the primitives described in the
following specification.

## Basics

The main assumption is that any application UI described in most simplified form can be equal to API
scheme served by application backend. So the user interface in fact is nothing more than a
formalized access to some API decorated and presented in convenient for the user form.

So, any application API that will fit some restrictions will be possible to automatically render as
user interfaces. Of course using autogenerated UI wouldn't be mandatory, user is free to use any UI
rendering app compatible with service.

Most of those ideas aren't new, and can be found already implemented in different combinations for
solving real problems. So solution for our UI issues should be based on already well known
components, connected and suited in proper way.

## Motivation

Consider a model where anyone can be a customer, a service or a both. The services are providing a
value which is wanted by a customers, so anyone can serve by creating a value and getting a payment.
Of course, we are smart and we are automating any redundant operation worth it. Keeping eyes only on
a pure intention makes a things easier and possible to solve, but someone always have to do the
repeatable part. Nowadays we have a computers as a slaves, but developing services and applications
still is a big effort.

In summary, smart humans can spend their time on a nice things because they are automating
unpleasant part of life instead of doing it all over again, but automating could be much easier.

## Goals

* Writing application UI should be optional in any stage of development. This gives a great ability
  for delivering solution without wasting time on solving repeatable UI problems.
* Application UI can be automatically generated from single source of truth API definition.
* User has a full freedom of choose how to render the data provided by service.

## References

* [Open RPC](https://open-rpc.org/getting-started)
* [JSON Schema](https://json-schema.org/)
    * [Random article](https://sairamkrish.medium.com/rapid-development-of-data-collection-platform-with-reactjs-and-json-schema-ef147f4c665)
    * [JSON Forms](https://jsonforms.io/)
    * [neat-form](https://github.com/ellykits/neat-form)
* [apache thrift](https://github.com/apache/thrift)
* [UI libs](https://proandroiddev.com/dynamic-screens-using-server-driven-ui-in-android-262f1e7875c1)

## Design

In programming, the most easies way for providing some functionality is to write a library which is
providing its API through public functions and structures, but in most cases it is not sufficient
for the customer. In most cases the simple programming interfaces needs to be wrapped in UI code for
providing the convenient access for the end user. We can easily assume that are many ways for
wrapping and calling the public API, so the public API should be a single source of true and base
for building GUI.

### API

Can be written in any language or DSL. The source of true about UI scheme. Is used to autogenerate
the scheme. Also, is used for translating RPC calls into service function calls.

For convenience any file with code that is exposing some application public API can be parsed into
the scheme, can also be considered as API definition file.

#### Restrictions

All data types should be possible to parse and format into related types specified in scheme
restrictions.

#### Representation

The example API representation in kotlin lang:

```kotlin
data class Element(
    val id: Int,
    val map: Map<String, String>,
)

data class Elements(
    val list: List<Element>,
)


interface Api {

    suspend fun getElements(): Elements

    suspend fun addElement(element: Element)

    fun elementsFlow(contains: List<String>): Flow<Element>

    interface SomeProcess {

        suspend fun getOptions(): List<Element>

        suspend fun selectOption(index: Int)

        suspend fun setValue(value: String)
    }
}
```

In some cases when the bi-directions stream is more preferred than classic function calls, the
functions can be represented using data structures:

```kotlin
object Api {

    data class GetElements(val returns: Element? = null)

    data class AddElement(val element: Element)

    data class ElementsFlow(val contains: List<String>, val returns: Flow<Element>? = null)

    object SomeProcess {

        suspend fun getOptions(): List<Element>

        suspend fun selectOption(index: Int)

        suspend fun setValue(value: String)
    }
}
```

### Scheme

The formalized data structure that describes API definition (structures and functions). Depending on
needs can be represented in any format designed for describing data structures (json, yaml, gob...).

#### Restrictions

The following type restrictions should be sufficient for UI rendering purpose.

* Primitive - boolean, number, string
* Container - array, map
* Struct - the composition of names associated to types
* Function - a tuple of name arg type and return type
* Callback - a listener for specific data stream deferred in time
* Process - a set of functions used to fulfil a data in specific context for complete a process.

#### Representation

Most of popular formal languages designed for describing data can be used for the scheme
representation.

The example draft of scheme representation in json format.

```json
{
  "version": 1,
  "type": "scheme",
  "name": "Service name",
  "structures": {
    "element": {
      "id": "int",
      "value": "string",
      "list": [
        "list",
        "int"
      ]
    },
    "elements": {
      "map": [
        "map",
        "element"
      ]
    }
  },
  "functions": {
    "getElements": {
      "returns": "elements"
    },
    "setElement": {
      "args": [
        "element"
      ]
    },
    "elementsFlow": {
      "args": [
        [
          "list",
          "int"
        ]
      ],
      "returns": [
        "flow",
        "element"
      ]
    }
  }
}
```

Consider to use official json schema to solve representation issue.

### Layout

Additional layer of data build upon the scheme. Contains info how render the associated scheme.
Layout can by automatically generated or/and written manually. This layer can be optional or
restricted depending on GUI implementation.

```json
{
  "version": 1,
  "type": "layout",
  "name": "Layout name",
  "scheme": {
    "version": 1,
    "name": "Service name"
  },
  "style": {
    "custom-list-style": {
      "margin": 8
    }
  },
  "layout": {
    "elements": {
      "style": [
        "custom-list-style"
      ],
      "source": [
        "getElements"
      ]
    }
  }
}
```

### Service

The service application that is providing API methods and can serve structured data. Service
compatible with Open UI additionally must provide a scheme for the clients.

### GUI

The client application that can call service API methods. Basing on scheme and layout, can
automatically render the UI. Is responsible for translating input from user into the RPC calls.
